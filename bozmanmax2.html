<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>BOZ man max — Castle Types & Waves</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#7ec0ee;--panel:rgba(0,0,0,0.6);--accent:#ffcc00}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#fff}
  #wrap{display:flex;align-items:center;justify-content:center;height:100vh;background:linear-gradient(180deg,#6fb7ff,#7ec0ee)}
  canvas{display:block;background:transparent;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.35)}
  .panel{position:fixed;padding:10px;border-radius:10px;background:var(--panel);backdrop-filter: blur(4px)}
  #ui{left:12px;top:12px;width:300px}
  #ui b{display:block;font-size:18px;margin-bottom:6px}
  #buildMenu{left:12px;bottom:12px;width:320px;display:flex;gap:8px;flex-wrap:wrap}
  .buildBtn{flex:1;padding:8px;border-radius:8px;border:0;background:#333;color:#fff;cursor:pointer}
  .buildBtn.active{outline:3px solid rgba(255,204,0,0.6)}
  #minimap{right:12px;bottom:12px;width:180px;height:130px}
  #wavePanel{right:12px;top:12px;width:220px;text-align:right}
  #loadingScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(3,3,10,0.85), rgba(3,3,10,0.6));z-index:40}
  #rules{width:760px;max-width:92%;background:linear-gradient(180deg,#0b1220,#07101a);padding:20px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  #deathOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:50}
  #deathCard{background:#111;padding:18px;border-radius:10px;text-align:center;width:360px}
  #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:45;pointer-events:none}
  #pauseBadge{background:rgba(0,0,0,0.55);padding:10px 16px;border-radius:8px;border:2px solid rgba(255,204,0,0.12);font-weight:700}
  button{appearance:none;border:0;padding:8px 12px;border-radius:8px;background:var(--accent);color:#111;font-weight:600;cursor:pointer}
  small{opacity:0.9}
  @media (max-width:700px){#rules{padding:14px};canvas{width:95vw;height:60vh}}
</style>
</head>
<body>
<div id="wrap"><canvas id="game" width="1024" height="640"></canvas></div>

<!-- UI -->
<div id="ui" class="panel">
  <b>BOZ man max</b>
  <div>Wood: <span id="wood">0</span></div>
  <div>HP: <span id="hp">100</span></div>
  <div>Selected: <span id="selected">None</span></div>
  <div style="margin-top:8px"><small>Move: WASD / Arrows • Click to build • 1 spawn soldier</small></div>
  <div style="margin-top:8px;display:flex;gap:8px">
    <button id="pauseBtn">Pause</button>
    <button id="hardBtn">Harder</button>
  </div>
</div>

<div id="buildMenu" class="panel">
  <!-- Buttons inserted by script -->
</div>

<div id="minimap" class="panel"></div>

<div id="wavePanel" class="panel">
  <div><b>Wave</b></div>
  <div>Level: <span id="waveLevel">0</span></div>
  <div>Wave: <span id="waveNum">0</span></div>
  <div>Next in: <span id="waveTimer">--</span>s</div>
</div>

<!-- Loading / Rules Screen -->
<div id="loadingScreen">
  <div id="rules">
    <h1>BOZ man max — How to play</h1>
    <p>Build different castle structures, defend against waves, and manage wood. Use the build menu to place Walls, Towers, Turrets, or Lumber Mills (wood mines).</p>
    <ul>
      <li><strong>Wall</strong> — cheap, basic HP.</li>
      <li><strong>Tower</strong> — stronger block with more HP. Now attacks enemies.</li>
      <li><strong>Turret</strong> — auto-shoots enemies in range.</li>
      <li><strong>Lumber Mill</strong> — passive wood generator (best for steady income).</li>
    </ul>
    <p><strong>Waves</strong> increase in difficulty quickly. Prepare before the timer ends. Use mills to avoid slow tree gathering.</p>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
      <button id="startBtn">Start Game</button>
    </div>
  </div>
</div>

<!-- Death overlay -->
<div id="deathOverlay">
  <div id="deathCard">
    <h2>You died</h2>
    <p id="deathMsg">You were defeated. Respawn to try again.</p>
    <div style="margin-top:12px">
      <button id="respawnBtn">Respawn</button>
    </div>
  </div>
</div>

<!-- Pause badge -->
<div id="pauseOverlay">
  <div id="pauseBadge">PAUSED</div>
</div>

<script>
// ====== Config ======
const CONFIG = {
  worldW: 2400, worldH: 1600,
  playerSpeed: 3.6,
  gatherPerSecond: 3.0, // faster tree gathering
  gatherRange: 48,
  tick: 1000/60,
  buildRange: 260,
  // scaling coefficients (stronger)
  enemyHpPerLevel: 0.35,   // +35% HP per level
  enemyAtkPerLevel: 0.18,  // +18% ATK per level
  enemySpeedPerLevel: 0.06 // +6% speed per level
};

// ====== Canvas & UI ======
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimapEl = document.getElementById('minimap');
const mmCanvas = document.createElement('canvas'); mmCanvas.width=180; mmCanvas.height=130; mmCanvas.style.width='100%'; mmCanvas.style.height='100%'; minimapEl.appendChild(mmCanvas);
const mmCtx = mmCanvas.getContext('2d');
const woodEl = document.getElementById('wood'), hpEl = document.getElementById('hp'), selectedEl = document.getElementById('selected');
const waveLevelEl = document.getElementById('waveLevel'), waveNumEl = document.getElementById('waveNum'), waveTimerEl = document.getElementById('waveTimer');
const buildMenu = document.getElementById('buildMenu');
const loadingScreen = document.getElementById('loadingScreen'), startBtn = document.getElementById('startBtn');
const deathOverlay = document.getElementById('deathOverlay'), respawnBtn = document.getElementById('respawnBtn'), deathMsg = document.getElementById('deathMsg');
const pauseBtn = document.getElementById('pauseBtn'), pauseOverlay = document.getElementById('pauseOverlay');
const hardBtn = document.getElementById('hardBtn');

// ====== Structures definition ======
const STRUCTURES = {
  wall: { name:'Wall', cost:10, w:44, h:44, hp:220, desc:'Basic wall' },
  tower: { name:'Tower', cost:22, w:52, h:52, hp:420, desc:'Strong defensive tower', range:160, fireRate:1100, dmg:28 },
  turret: { name:'Turret', cost:30, w:48, h:48, hp:200, desc:'Auto-shoots enemies' , range:160, fireRate:900, dmg:18 },
  mill: { name:'Lumber Mill', cost:25, w:56, h:56, hp:180, desc:'Generates wood over time', producePerSec:1.2 }
};

// ====== Enemy types per level (base stats)
const ENEMY_TYPES = [
  { id:'grunt', hp:60, atk:6, speed:1.05, color:'#b22222', size:12 },
  { id:'brute', hp:120, atk:10, speed:0.8, color:'#8b0000', size:14 },
  { id:'runner', hp:40, atk:5, speed:1.6, color:'#ff4500', size:10 },
  // Troll: appears wave 3+
  { id:'troll', hp:250, atk:22, speed:0.7, color:'#556b2f', size:18 },
  // Dragon: appears wave 6+
  { id:'dragon', hp:420, atk:35, speed:1.2, color:'#663399', size:20 }
];

// ====== Wave definitions (base)
const WAVE_BASE = [
  { level:1, spawn: [{type:'grunt',count:6}] },
  { level:2, spawn: [{type:'grunt',count:8}] },
  { level:3, spawn: [{type:'grunt',count:6},{type:'runner',count:4}] },
  { level:4, spawn: [{type:'brute',count:3},{type:'grunt',count:6}] },
  { level:5, spawn: [{type:'brute',count:4},{type:'runner',count:6}] }
];

// ====== State ======
const state = {
  player: { x: CONFIG.worldW/2, y: CONFIG.worldH/2, r:14, hp:100, wood:30, alive:true },
  keys: {}, trees: [], blocks: [], enemies: [], units: [], time:0,
  gatherProgress:0, gatheringTree:null, selectedBuild:null,
  wave: { level:1, number:0, nextIn:12, active:false, spawnQueue:[], spawnTimer:0 },
  paused: false,
  hardMode: false
};

// ====== Helpers ======
function rand(min,max){ return Math.random()*(max-min)+min }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)) }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y) }
function distXY(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by) }

// ====== Populate world ======
for(let i=0;i<50;i++) state.trees.push({ x: rand(80,CONFIG.worldW-80), y: rand(80,CONFIG.worldH-80), r: 20, wood: 50 });
for(let i=0;i<4;i++) spawnEnemy(rand(200,CONFIG.worldW-200), rand(200,CONFIG.worldH-200));

// ====== Build menu UI ======
function makeBuildButtons(){
  for(const key in STRUCTURES){
    const s = STRUCTURES[key];
    const btn = document.createElement('button');
    btn.className = 'buildBtn';
    btn.innerHTML = `${s.name}<br><small>Cost: ${s.cost}</small>`;
    btn.onclick = () => {
      // toggle selection
      if(state.selectedBuild === key){ state.selectedBuild = null; btn.classList.remove('active'); selectedEl.textContent = 'None'; return; }
      state.selectedBuild = key;
      selectedEl.textContent = s.name;
      // mark active
      document.querySelectorAll('.buildBtn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
    };
    buildMenu.appendChild(btn);
  }
}
makeBuildButtons();

// ====== Input ======
window.addEventListener('keydown', e => state.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => state.keys[e.key.toLowerCase()] = false);
canvas.addEventListener('click', e => {
  if(!state.player.alive || state.paused) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const cam = camera();
  const wx = cam.x + mx, wy = cam.y + my;
  if(state.selectedBuild) placeStructure(state.selectedBuild, wx, wy);
});
window.addEventListener('keypress', e => { if(e.key === '1') spawnUnit(); });

// pause/hard buttons
pauseBtn.addEventListener('click', ()=>{ togglePause(); });
hardBtn.addEventListener('click', ()=>{ state.hardMode = !state.hardMode; hardBtn.textContent = state.hardMode ? 'Harder ✓' : 'Harder'; });

// ====== Camera ======
function camera(){ const p=state.player; return { x: clamp(p.x - canvas.width/2, 0, CONFIG.worldW - canvas.width), y: clamp(p.y - canvas.height/2, 0, CONFIG.worldH - canvas.height) }; }

// ====== Actions ======
function placeStructure(key, wx, wy){
  const s = STRUCTURES[key];
  if(!s) return;
  if(state.player.wood < s.cost) return;
  if(distXY(state.player.x, state.player.y, wx, wy) > CONFIG.buildRange) return;
  // overlap check
  for(const b of state.blocks) if(Math.abs(b.x - wx) < (b.w/2 + s.w/2) && Math.abs(b.y - wy) < (b.h/2 + s.h/2)) return;
  const block = { type:key, x:wx, y:wy, w:s.w, h:s.h, hp:s.hp, owner:'player', created:Date.now(), lastFire:0, produceTimer:0 };
  state.blocks.push(block);
  state.player.wood -= s.cost;
}

function spawnUnit(){
  if(state.player.wood < 15 || state.paused) return;
  state.player.wood -= 15;
  const u = { x: state.player.x + rand(-30,30), y: state.player.y + rand(-30,30), hp: 70, atk: 9, speed: 1.6, owner: 'player' };
  state.units.push(u);
}

function spawnEnemy(x,y,typeId){
  const base = ENEMY_TYPES.find(t=>t.id===typeId) || ENEMY_TYPES[0];
  // scale HP/atk/speed aggressively with wave level
  const lvl = state.wave.level || 1;
  const hp = Math.max(8, Math.round(base.hp * (1 + (lvl-1) * CONFIG.enemyHpPerLevel)));
  const atk = Math.max(1, Math.round(base.atk * (1 + (lvl-1) * CONFIG.enemyAtkPerLevel)));
  const speed = base.speed * (1 + (lvl-1) * CONFIG.enemySpeedPerLevel);
  const e = { x,y, hp: hp, atk: atk, speed: speed, color: base.color, type: base.id, size: base.size || 12 };
  state.enemies.push(e);
}

// ====== Wave system ======
function scheduleNextWave(){
  state.wave.number++;
  state.wave.active = true;
  const pattern = WAVE_BASE[(state.wave.number-1) % WAVE_BASE.length];
  // quicker growth
  const rounds = Math.floor((state.wave.number-1)/WAVE_BASE.length);
  const multiplier = 1 + rounds * 0.9 + (state.hardMode ? 0.4 : 0);
  const queue = [];
  for(const group of pattern.spawn){
    for(let i=0;i<Math.ceil(group.count * multiplier); i++){
      queue.push(group.type);
    }
  }
  // trolls start appearing from wave 3
  if(state.wave.number >= 3){
    for(let i=0;i<Math.floor(state.wave.number/3); i++) queue.push('troll');
  }
  // dragons from wave 6
  if(state.wave.number >= 6){
    for(let i=0;i<Math.floor(state.wave.number/6); i++) queue.push('dragon');
  }
  // shuffle
  for(let i=queue.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [queue[i],queue[j]]=[queue[j],queue[i]]; }
  state.wave.spawnQueue = queue;
  state.wave.spawnTimer = 0;
  waveNumEl.textContent = state.wave.number;
}

function tickWave(dt){
  if(state.paused) return;
  if(state.wave.active){
    if(state.wave.spawnQueue.length > 0){
      state.wave.spawnTimer = (state.wave.spawnTimer || 0) - dt;
      const interval = Math.max(220, 600 - state.wave.level*22);
      const spawnInterval = state.hardMode ? Math.max(120, interval * 0.75) : interval;
      if(state.wave.spawnTimer <= 0){
        const type = state.wave.spawnQueue.shift();
        // spawn at random edge
        const edge = Math.floor(rand(0,4));
        let x=0,y=0;
        if(edge===0){ x=rand(0,CONFIG.worldW); y=0 }
        if(edge===1){ x=CONFIG.worldW; y=rand(0,CONFIG.worldH) }
        if(edge===2){ x=rand(0,CONFIG.worldW); y=CONFIG.worldH }
        if(edge===3){ x=0; y=rand(0,CONFIG.worldH) }
        spawnEnemy(x,y,type);
        state.wave.spawnTimer = spawnInterval;
      }
    } else {
      // wave finished
      state.wave.active = false;
      state.wave.level += 1;
      state.wave.nextIn = 12 + Math.max(0, 6 - Math.floor(state.wave.level/3));
      if(state.hardMode) state.wave.nextIn = Math.max(3, Math.floor(state.wave.nextIn * 0.6));
    }
  } else {
    state.wave.nextIn -= dt/1000;
    if(state.wave.nextIn <= 0){
      scheduleNextWave();
    }
  }
  waveLevelEl.textContent = state.wave.level;
  waveTimerEl.textContent = Math.max(0, Math.ceil(state.wave.nextIn));
}

// ====== Update loop ======
let last = performance.now();
function update(dt){
  state.time += dt;
  if(state.paused) return;
  if(!state.player.alive) return;

  // movement
  let dx=0, dy=0;
  if(state.keys['w']||state.keys['arrowup']) dy -= 1;
  if(state.keys['s']||state.keys['arrowdown']) dy += 1;
  if(state.keys['a']||state.keys['arrowleft']) dx -= 1;
  if(state.keys['d']||state.keys['arrowright']) dx += 1;
  const len = Math.hypot(dx,dy) || 1;
  state.player.x += (dx/len) * CONFIG.playerSpeed;
  state.player.y += (dy/len) * CONFIG.playerSpeed;
  state.player.x = clamp(state.player.x, 0, CONFIG.worldW);
  state.player.y = clamp(state.player.y, 0, CONFIG.worldH);

  // gathering from trees (faster)
  let nearest=null, nd=1e9;
  for(const t of state.trees) if(t.wood>0){ const d=distXY(t.x,t.y,state.player.x,state.player.y); if(d<nd){nd=d;nearest=t;} }
  if(nearest && nd <= CONFIG.gatherRange){
    if(Math.hypot(dx,dy) < 0.5){
      state.gatheringTree = nearest;
      state.gatherProgress += (CONFIG.gatherPerSecond * (dt/1000));
      while(state.gatherProgress >= 1 && state.gatheringTree && state.gatheringTree.wood > 0){
        state.player.wood += 1;
        state.gatheringTree.wood -= 1;
        state.gatherProgress -= 1;
      }
    } else { state.gatherProgress = Math.max(0, state.gatherProgress - (dt/1000)*2); state.gatheringTree=null; }
  } else { state.gatherProgress = Math.max(0, state.gatherProgress - (dt/1000)*2); state.gatheringTree=null; }

  // mills produce wood passively
  for(const b of state.blocks){
    if(b.type === 'mill'){
      b.produceTimer = (b.produceTimer || 0) + dt;
      const s = STRUCTURES.mill.producePerSec;
      const interval = 1000 / s;
      while(b.produceTimer >= interval){
        b.produceTimer -= interval;
        // give wood to player
        state.player.wood += 1;
      }
    }
  }

  // turrets & towers auto-fire (towers apply knockback)
  for(const b of state.blocks){
    if(b.type === 'turret' || b.type === 'tower'){
      b.lastFire = (b.lastFire || 0) + dt;
      const s = STRUCTURES[b.type];
      if(b.lastFire >= s.fireRate){
        // find nearest enemy in range
        let target=null, best=1e9;
        for(const e of state.enemies){ const d = Math.hypot(e.x-b.x, e.y-b.y); if(d < best && d <= s.range){ best=d; target=e; } }
        if(target){
          target.hp -= s.dmg;
          if(b.type === 'tower'){
            const dx = target.x - b.x, dy = target.y - b.y; const d = Math.hypot(dx,dy)||1;
            target.x += (dx/d) * 6;
            target.y += (dy/d) * 6;
          }
          b.lastFire = 0;
        }
      }
    }
  }

  // units AI
  for(const u of state.units){
    if(u.hp <= 0) continue;
    let target=null, best=1e9;
    for(const e of state.enemies){ const d=Math.hypot(e.x-u.x,e.y-u.y); if(d<best){best=d;target=e;} }
    for(const b of state.blocks){ if(b.owner!=='player'){ const d=Math.hypot(b.x-u.x,b.y-u.y); if(d<best){best=d;target=b;} } }
    if(target){
      const vx=target.x-u.x, vy=target.y-u.y, d=Math.hypot(vx,vy)||1;
      if(d>18){ u.x += (vx/d)*u.speed; u.y += (vy/d)*u.speed; } else { if(target.hp!==undefined) target.hp -= u.atk * (dt/100); }
    } else { u.x += rand(-0.4,0.4); u.y += rand(-0.4,0.4); }
  }

  // enemies AI
  for(const e of state.enemies){
    if(e.hp <= 0) continue;
    let target=null, best=1e9;
    for(const b of state.blocks){ const d=Math.hypot(b.x-e.x,b.y-e.y); if(d<best){best=d;target=b;} }
    const dp = Math.hypot(state.player.x - e.x, state.player.y - e.y);
    if(dp < best){ best = dp; target = state.player; }
    if(target){
      const vx=target.x-e.x, vy=target.y-e.y, d=Math.hypot(vx,vy)||1;
      if(d>20){ e.x += (vx/d)*e.speed; e.y += (vy/d)*e.speed; } else { if(target.hp!==undefined) {
        // dragons hit harder
        const dmgMultiplier = (e.type === 'dragon' ? 1.8 : 1.0);
        target.hp -= e.atk * (dt/700) * dmgMultiplier;
      } }
    } else { e.x += rand(-0.3,0.3); e.y += rand(-0.3,0.3); }
  }

  // cleanup dead
  state.units = state.units.filter(u=>u.hp>0);
  state.enemies = state.enemies.filter(e=>e.hp>-50);
  state.blocks = state.blocks.filter(b=>b.hp>0);

  // player death
  if(state.player.hp <= 0){ state.player.alive=false; state.player.hp=0; showDeath(); }

  // wave tick
  tickWave(dt);

  // UI update
  woodEl.textContent = Math.floor(state.player.wood);
  hpEl.textContent = Math.max(0, Math.floor(state.player.hp));
}

// ====== Draw ======
function draw(){
  const cam = camera();
  // sky
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const sky = ctx.createLinearGradient(0,0,0,canvas.height); sky.addColorStop(0,'#7ec0ee'); sky.addColorStop(1,'#6fb7ff');
  ctx.fillStyle = sky; ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.save(); ctx.translate(-cam.x, -cam.y);
  // ground
  ctx.fillStyle = '#6aa84f'; ctx.fillRect(0,0,CONFIG.worldW, CONFIG.worldH);

  // trees
  for(const t of state.trees){
    ctx.fillStyle = '#6b3'; ctx.fillRect(t.x-6, t.y+8, 12, 18);
    const grd = ctx.createRadialGradient(t.x, t.y-6, 6, t.x, t.y-6, 28); grd.addColorStop(0,'#9fe08a'); grd.addColorStop(1,'#2e8b57');
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(t.x, t.y-6, 28, 0, Math.PI*2); ctx.fill();
    if(t.wood<=0){ ctx.fillStyle='#4b3b2a'; ctx.fillRect(t.x-10, t.y+6, 20, 8); }
  }

  // blocks
  for(const b of state.blocks){
    // shadow
    ctx.fillStyle='rgba(0,0,0,0.22)'; ctx.fillRect(b.x - b.w/2 + 6, b.y - b.h/2 + 8, b.w, b.h);
    // draw by type
    if(b.type==='wall'){ ctx.fillStyle='#8B4513'; ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h); }
    if(b.type==='tower'){ ctx.fillStyle='#6e3b1a'; ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h); ctx.fillStyle='#000'; ctx.fillRect(b.x-6,b.y-12,12,6); }
    if(b.type==='turret'){ ctx.fillStyle='#444'; ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h); ctx.fillStyle='#ffd54d'; ctx.beginPath(); ctx.arc(b.x, b.y-6, 8, 0, Math.PI*2); ctx.fill(); }
    if(b.type==='mill'){ ctx.fillStyle='#7a5'; ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h); ctx.fillStyle='#4b3b2a'; ctx.fillRect(b.x-10,b.y+6,20,8); }
    // hp bar
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(b.x-22, b.y - b.h/2 - 10, 44, 6);
    ctx.fillStyle='#0f0'; const pct = clamp(b.hp / (STRUCTURES[b.type].hp || 200), 0,1);
    ctx.fillRect(b.x-22, b.y - b.h/2 - 10, 44*pct, 6);

    // show turret/tower ranges lightly
    if(b.type==='turret' || b.type==='tower'){
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.arc(b.x, b.y, STRUCTURES[b.type].range, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // units
  for(const u of state.units){
    ctx.fillStyle='#2f6fff'; ctx.beginPath(); ctx.arc(u.x, u.y, 8, 0, Math.PI*2); ctx.fill();
  }

  // enemies
  for(const e of state.enemies){
    ctx.fillStyle = e.color || '#b22222'; ctx.beginPath(); ctx.arc(e.x, e.y, e.size || 12, 0, Math.PI*2); ctx.fill();
  }

  // player
  const p = state.player;
  ctx.fillStyle='#0033aa'; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // gather UI
  if(state.gatheringTree){
    const cam2 = camera();
    const gx = state.gatheringTree.x - cam2.x, gy = state.gatheringTree.y - cam2.y - 40;
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(gx-36, gy-8, 72, 12);
    ctx.fillStyle='#ffd54d'; const w = clamp(state.gatherProgress,0,1) * 72; ctx.fillRect(gx-36, gy-8, w, 12);
    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.strokeRect(gx-36, gy-8, 72, 12);
  }

  // minimap
  drawMinimap();

  // pause overlay
  pauseOverlay.style.display = state.paused ? 'flex' : 'none';
}

// ====== Minimap ======
function drawMinimap(){
  const mmW = mmCanvas.width, mmH = mmCanvas.height;
  mmCtx.clearRect(0,0,mmW,mmH);
  mmCtx.fillStyle='#0b1220'; mmCtx.fillRect(0,0,mmW,mmH);
  const sx = mmW / CONFIG.worldW, sy = mmH / CONFIG.worldH;
  mmCtx.fillStyle='#2e8b57'; for(const t of state.trees) mmCtx.fillRect(t.x*sx, t.y*sy, 2,2);
  for(const b of state.blocks){ mmCtx.fillStyle = b.owner==='player' ? '#8B4513' : '#555'; mmCtx.fillRect((b.x-b.w/2)*sx, (b.y-b.h/2)*sy, b.w*sx, b.h*sy); }
  mmCtx.fillStyle='#f55'; for(const e of state.enemies) mmCtx.fillRect(e.x*sx, e.y*sy, 3,3);
  mmCtx.fillStyle='#00f'; mmCtx.fillRect(state.player.x*sx-2, state.player.y*sy-2, 4,4);
}

// ====== Death UI ======
function showDeath(){ deathMsg.textContent = `You died. You lost some wood (${Math.floor(state.player.wood*0.4)}).`; deathOverlay.style.display='flex'; }
respawnBtn.addEventListener('click', ()=>{ respawnPlayer(); deathOverlay.style.display='none'; });

// ====== Respawn ======
function respawnPlayer(){ state.player.x = CONFIG.worldW/2 + rand(-60,60); state.player.y = CONFIG.worldH/2 + rand(-60,60); state.player.hp = 100; state.player.wood = Math.max(0, Math.floor(state.player.wood * 0.6)); state.player.alive = true; state.gatherProgress=0; state.gatheringTree=null; }

// ====== Pause ======
function togglePause(){
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
  if(!state.paused) lastTime = performance.now(); // avoid big dt jump
}

// ====== Main loop ======
let lastTime = performance.now();
function loop(now){
  const dt = now - lastTime; lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ====== Start & responsive ======
startBtn.addEventListener('click', ()=>{ loadingScreen.style.display='none'; state.wave.nextIn = 8; lastTime = performance.now(); });
function fitCanvas(){ const maxW = Math.min(window.innerWidth - 40, 1200); const maxH = Math.min(window.innerHeight - 40, 760); const ratio = canvas.width / canvas.height; let newW = maxW, newH = Math.round(newW / ratio); if(newH > maxH){ newH = maxH; newW = Math.round(newH * ratio); } canvas.style.width = newW + 'px'; canvas.style.height = newH + 'px'; }
window.addEventListener('resize', fitCanvas); fitCanvas();

</script>
</body>
</html>
